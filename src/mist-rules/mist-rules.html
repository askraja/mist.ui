<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-styles/typography.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/paper-spinner/paper-spinner.html">

<link rel="import" href="rules-item.html">
<link rel="import" href="rule-edit.html">

<dom-module id="mist-rules">
    <template>
        <style>
            :host {
                display: block;
            }

            paper-button {
                padding: 0.8em 1.57em 0.7em 1.57em;
                font-weight: 500;
            }

            paper-button[disabled] {
                background-color: rgba(0, 0, 0, .13) !important;
                color: rgba(0, 0, 0, 0.32) !important;
            }

            paper-material {
                border-top: 2px solid #ddd;
            }

            paper-button iron-icon {
                opacity: 0.32;
                padding: 4px;
            }

            rule-edit {
                padding: 0 24px 16px 24px;
            }

            .rule-actions {
                justify-content: flex-end;
                font-size: 0.9em;
                margin-top: 16px;
            }
        </style>
        <paper-material elevation="0">
            <template is="dom-repeat" items="{{items}}">
                <rules-item builtin-metrics="[[builtinMetrics]]" custom-metrics="[[customMetrics]]" rule="[[item]]" incidents="[[incidents]]"
                    resource="[[resource]]" model="[[model]]" teams="[[teams]]" users="[[users]]"></rules-item>
            </template>

            <paper-button toggles active="{{editNew}}" hidden$="{{editNew}}">
                <iron-icon icon="icons:add-circle"></iron-icon> add new rule</paper-button>

            <rule-edit rule={{newRule}} builtin-metrics=[[builtinMetrics]] custom-metrics=[[customMetrics]] available-metrics=[[availableMetrics]]
                machine=[[machine]] cloud=[[cloud]] resource=[[resource]] form-error=[[formError]] form-message=[[formMessage]]
                users="[[model.membersArray]]" teams="[[model.teamsArray]]" edit-new="{{editNew}}" hidden$="{{!editNew}}">
                <div slot="rule-actions" class="rule-actions layout horizontal" hidden$="[[updateExistingRule]]">
                    <p class="errormsg-container" hidden$="[[!formError]]">
                        <iron-icon icon="icons:error-outline"></iron-icon>
                        <span id="errormsg">[[formMessage]]</span>
                    </p>
                    <paper-spinner active$="{{sendingData}}"></paper-spinner>
                    <paper-button toggles active="{{editNew}}" class="link">cancel</paper-button>
                    <paper-button on-tap="addRule" class="blue" disabled$="[[!isValideRule]]">save rule</paper-button>
                </div>
            </rule-edit>

        </paper-material>

        <iron-ajax id="addRuleRequest" url="/api/v1/rules" contentType="application/json" method="POST" on-request="_handleAddRequest"
            on-response="_handleAddResponse" on-error="_handleAddError" loading="{{sendingData}}"></iron-ajax>

    </template>

    <script>
        Polymer({
            is: 'mist-rules',

            properties: {
                incidents: {
                    type: Array
                },
                machine: {
                    type: String,
                    value: ''
                },
                cloud: {
                    type: String,
                    value: ''
                },
                resource: Object, // machine, cloud or other later
                model: Object,
                rules: {
                    type: Object,
                    notify: true
                },
                items: {
                    type: Array,
                    value: []
                },
                builtinMetrics: {
                    type: Object,
                    notify: true,
                    value: {}
                },
                customMetrics: {
                    type: Object,
                    notify: true,
                    value: {}
                },
                availableMetrics: {
                    type: Array,
                    computed: "_computeMetrics(resource, builtinMetrics, customMetrics)"
                },
                newRule: Object,
                editNew: {
                    type: Boolean,
                    value: false // TODO revert to false 
                },
                formError: {
                    type: Boolean,
                    value: false
                },
                teams: Array,
                users: Array,
                isValideRule: {
                    type: Boolean,
                    value: false,
                    notify: true
                }
            },
            listeners: {
                'iron-select': 'userChanges',
                'input': 'userChanges',
                'edit-request': 'editRequest',
                'add-rule': 'addRule'
            },
            observers: [
                "_computeRules(rules.*, machine, cloud)",
                "ruleChanged(newRule.*)"
            ],
            ready: function () {
                this.init();
            },
            init: function () {
                this.set("emails", "");
                var new_rule = {
                    metric: "load.shortterm",
                    operator: "gt",
                    value: 5,
                    aggregate: 'any',
                    action: '',
                    reminder_offset: '1',
                    command: '',
                    emails: '',
                    teams: [],
                    users: []
                }
                this.set('newRule', new_rule);
            },
            _computeRules: function (rules, machine, cloud) {
                var rulesArray = [],
                    thisMachineRules = [];
                if (this.rules) {
                    for (var rule in this.rules) {
                        rulesArray.push(this.rules[rule]);
                    }
                }
                thisMachineRules = rulesArray.filter(function (r) {
                    console.log('r.machine', r.machine == machine, 'r.cloud', r.cloud == cloud);
                    return (r.machine == machine && r.cloud == cloud);
                }).reverse();

                this.set('items', thisMachineRules);
            },
            _computeMetrics: function (resource, builtinMetrics, customMetrics) {
                var metrics = [];
                for (var p in this.builtinMetrics) {
                    metrics.push(this.builtinMetrics[p])
                }
                if (this.customMetrics) {
                    for (var q in this.customMetrics) {
                        if (this.customMetrics[q].machines) {
                            var machineHasCustomMetric = this.customMetrics[q].machines.find(function (m) {
                                return m[0] == this.resource.cloud.id && m[1] == this.resource.machine_id;
                            }, this);
                            if (machineHasCustomMetric)
                                metrics.push(this.customMetrics[q])
                        }
                    }
                }
                return metrics;
            },
            addRule: function (e) {
                var payload = {};
                payload = this.newRule;

                payload.cloudId = this.resource.cloud.id;
                payload.machineId = this.resource.machine_id;

                if (payload["reminder_offset"])
                    payload["reminder_offset"] = (payload["reminder_offset"] - 1) * 60;
                // clean up command
                if (payload.action != "command") {
                    delete payload.command;
                }
                // clean up recipients
                if (payload.action != "alert") {
                    delete payload.emails;
                    delete payload.teams;
                    delete payload.users;
                }

                if (this.newRule.emails.length) {
                    var emails = this.newRule.emails.split(',');
                    payload["emails"] = [];
                    for (var i = 0; i < emails.length; i++) {
                        payload["emails"].push(emails[i].trim());
                    }
                }
                //error on empty string
                this.$.addRuleRequest.body = payload;
                this.$.addRuleRequest.headers["Content-Type"] = 'application/json';
                this.$.addRuleRequest.headers["Csrf-Token"] = CSRF_TOKEN;
                this.$.addRuleRequest.generateRequest();
            },
            _handleAddResponse: function () {
                this.set('editNew', false);
                this.set('formError', false);
                this.init();
            },
            _handleAddError: function (e) {
                console.log(e.detail.request.xhr.responseText);
                this.set('formMessage', e.detail.request.xhr.responseText)
                this.set('formError', true);
            },
            userChanges: function () {
                this.set('formError', false);
            },
            editRequest: function (e) {
                // handling of edit area
                var id = e.detail.rule;
                var els = this.querySelectorAll('rules-item');
                [].forEach.call(els, function (el, index) {
                    if (el.rule.id != id) {
                        el.set('editMode', false);
                    }
                });
            },
            ruleChanged: function (rule) {
                var valid = true;
                for (var p in this.newRule) {
                    if (this.newRule[p] == undefined)
                        valid = false;
                }

                if (this.newRule.action == '')
                    valid = false;

                if (this.newRule.action == 'alert') {
                    if (!this.newRule.emails.length && !this.newRule.teams.length && !this.newRule.users.length)
                        valid = false;
                }

                if (this.newRule.action == 'command')
                    if (!this.newRule.command || !this.newRule.command.length)
                        valid = false;

                this.set('isValideRule', valid);
            },
        });
    </script>
</dom-module>